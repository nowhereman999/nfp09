;
; NAM COMPARE
; TTL FLOATING PT. COMPARE FUNCTION
;
; LINKING LOADER DEFINITIONS
;
; XDEF  MAGCMP,INFAR2,INFAR1,CMPINF,NANCMP
; XDEF  CMPZER,ARG1UN,ARG2UN,BOTHUN
;
; XREF  SNORM,LNORM,ENORM,ROUND,IOPSET
;
; REVISION HISTORY:
;   DATE	PROGRAMMER     REASON
;
;  23.MAY.80	G. STEVENS     ORIGINAL
;  01.JUL.80	G. STEVENS     FIX CMP. STEP2 SO THAT IT
;			       DOESN'T BOMB THE CCR.
;  07.JUL.80	G. STEVENS     ADD ROUTINES FOR UNNORMALIZED
;  14.AUG.80	G. STEVENS     CHANGE CONDITIONS FOR ERRUN
;  19.AUG.80	G. STEVENS     ADD CODE TO HANDLE UNORMAL ZEROS
;  22.AUG.80	G. STEVENS     PREDICATE CMP'S SET UNORDERED PROPERLY
;  28.JUN.22    @thorpej       Updated for asm6809.  New
;                              comments are in mixed-case.
;
; HERE IS THE FUNCTION COMPARE AND ITS
; SUPPORT ROUTINES. AS WITH MOST OF THE
; OTHER FUNCTIONS, COMPARE MAKES USE OF
; A TABLE TO CALL ONE OF SEVERAL PROCEDURES
; DEPENDING ON THE TYPE OF THE INPUT OPERANDS.
; EACH OF THESE SUB PROCEDURES PERFORMS THE
; OPERATION AND THEN CALLS A GENERAL
; PROCEDURE TO DO THE FINAL ACTION OF
; EITHER RETURNING CONDITION CODES SET
; TO THE RESULT OF THE COMPARE OR
; AFFIRMING/DISAFFIRMING A SET OF INPUT
; PREDICATES.
;
;
; LOCAL EQUATES
;
; PREDICATE BIT EQUATES
; XXXJRT The BITn values are used a lot in this file.
; Should replace with the symbolic equates.
;
UN	EQU	BIT0
LT	EQU	BIT1
EQ	EQU	BIT2
GT	EQU	BIT3
NE	EQU	BIT4
GE	EQU	BIT3+BIT2
LE	EQU	BIT1+BIT2
;
; CONDITION CODE EQUATES
;
CCGT	EQU	00
CCLT	EQU	N
CCEQ	EQU	Z
CCUN	EQU	C

NCCGT	EQU	N+Z+V+C
NCCLT	EQU	Z+V+C
NCCEQ	EQU	N+V+C
NCCUN	EQU	N+Z+V

;*****************************************************************
;
; PROCEDURE A:
;
; NON SPECIAL CASE COMPARE
;
; PROCEDURE MAGCMP
;
;   MAGCMP DOES THE NON-SPECIAL CASE COMPARES
; IT FIST LOOKS AT THE SIGNS OF THE OPERANDS
; TO SEE IF THEY TELL THE STORY, AND THEN, IF
; NECESSARY COMPARES THE MAGNITUDES OF ARG1
; ARG2.
;
; CHECK THE SIGNS OF THE ARGUMENTS
;
MAGCMP
	LDA	ARG1,U		; SIGN ARG1
	EORA	ARG2,U		; SIGN ARG2

	BGE	MAGCMP_sign_same
	; SIGNS NOT THE SAME
	LDA	ARG1,U
	BGE	1F		; ARG1 NEGATIVE?
	LDB	#BIT1		; Yes, set <
	BRA	MAGCMP_done
1
	LDB	#BIT3		; No, set >
	BRA	MAGCMP_done

MAGCMP_sign_same
	;
	; ELSE IF THE SIGNS ARE THE SAME WILL
	; HAVE TO DO A MAGNITUDE ON ARG1 AND ARG2
	;
	LDD	EXP1,U
	CMPD	EXP2,U		; COMPARE EXPONENTS

	BEQ	MAGCMP_exp_eq
	; EXPONENTS UNEQUAL

	PSHS	CC		; SAVE CC REG.
	LDA	ARG1,U		; CHECK SIGN
	;
	; IF THE SIGN OF THE ARGUMENTS IS POSITIVE
	; THEN ASSIGN PREDICATES AS THE CONDITION
	; CODES INDICATE.
	;
	BLT	1F
	; SIGN BOTH POSITIVE
	PULS	CC		; GET ORIGINAL CC INFO
	BLE	2F
	LDB	#BIT3		; SET  >
	BRA	MAGCMP_done
2
	LDB	#BIT1		; SET  <
	BRA	MAGCMP_done
1
	;
	; ELSE IF SIGNS ORIGINALLY BOTH NEGATIVE
	; THEN CODITION CODES ARE OPPOSITE.
	;
	PULS	CC		; GET OSIGINAL CC INFO
	BLE	2F
	LDB	#BIT1		; SET  <
	BRA	MAGCMP_done
2
	LDB	#BIT3		; SET  >
	BRA	MAGCMP_done

MAGCMP_exp_eq
	;
	; SET UP THE COMPARE
	;
	LEAX	FRACT1,U
	LEAY	FRACT2,U
	CLRB
	LDA	B,X		; INITIALIZE A REG.
	;
	; COMPARE MAGNITUDES
	;
1	CMPA	B,Y
	BNE	1F
	CMPB	#(ARGSIZ-4)
	BGE	1F
	INCB
	LDA	B,X
	BRA	1B
1
	PSHS	CC		; SAVE CC REG.
	;
	; BASED ON THE CONDITION CODES AND SIGN
	; OF THE ARGUMENTS, GET PREDICATE BITS.
	;
	; IF B CONTAINS ( ARGSIZ-4 ) THE N THE
	; ARE EQUAL.
	;
	CMPB	#(ARGSIZ-4)
	BLT	1F
	LDB	#BIT2		; SET =
	LEAS	1,S		; RESTORE STACK
	BRA	MAGCMP_done
1
	LDA	ARG1,U		; CHECK SIGN
	;
	; IF THE SIGN OF THE ARGUMENTS IS POSITIVE
	; THEN ASSIGN PREDICATES AS THE CONDITION
	; CODES INDICATE.
	;
	BLT	1F
	PULS	CC		; GET ORIGINAL CC INFO
	BCS	2F
	LDB	#BIT3		; SET  >
	BRA	MAGCMP_done
2	
	LDB	#BIT1		; SET  <
	BRA	MAGCMP_done
1
	;
	; ELSE IF SIGNS ORIGINALLY BOTH NEGATIVE
	; THEN CODITION CODES ARE OPPOSITE.
	;
	PULS	CC		; GET OSIGINAL CC INFO
	BCS	2F
	LDB	#BIT1		; ;SET  <
	BRA	MAGCMP_done
2
	LDB	#BIT3		; SET  >
MAGCMP_done
	;
	; PROCEED TO STEP II TO EITHER SET CCR
	; OR AFFIRM/DISAFFIRM A PREDICATE.
	;
	; XXXJRT tail-call here?
	LBSR	CMPST2
	RTS			; RETURN

;*****************************************************************
;
; PROCEDURE B:
;
; INFINITY AS ARG2 AND ARG1 <> NAN OR INFINITY
;
;
; PROCEDURE  INFAR2
;
;   INFAR2 HANDLES THE CASE WHRER ARG2 IS
; INFINITY AND ARG1 IS NOT EITHER A NAN OR
; INFINITY.
;
; CHECK CLOSURE MODE
;
INFAR2
	LDA	[PFPCB,U]
	LSRA			; CLOSURE MODE BIT

	BCC	INFAR2_proj
	; AFFINE MODE
	LDA	ARG2,U
	;
	; IF AFFINE MODE AND ARG2 = PLUS INFINITY
	; THEN SIGNAL ARG1 > ARG2.
	;
	BLT	1F
	LDB	#BIT1		; SET  <
	BRA	INFAR2_done
1
	;
	; ELSE IF AFFINE MODE AND ARG2 = MINUS
	; INFINITY THEN SIGNAL ARG1 > ARG2.
	;
	LDB	#BIT3		; SET  >
	BRA	INFAR2_done

INFAR2_proj
	;
	; ELSE IF IN PROJECTIVE MODE THEN SIGNAL
	; UNORDERED.
	;
	LDB	#BIT0

INFAR2_done
	;
	; PROCEED TO STEP II TO EITHER SET CCR
	; OR AFFIRM/DISAFFIRM A PREDICATE.
	;
	; XXXJRT tail-call?
	LBSR  CMPST2
	RTS			; RETURN

;*****************************************************************
;
; PROCEDURE  C:
;
; INFINITY AS ARG1 AND ARG2 <> NAN OR INFINITY
;
;
; PROCEDURE  INFAR1
;
;    INFAR1 HANDLES THE CASE OF COMPARE WHERE
; ARG1 IS INFINITY AND ARG2 IS NOT EITHER A
; NAN OR INFINITY.
;
; CHECK CLOSURE MODE
;
INFAR1
	LDA	[PFPCB,U]
	LSRA

	BCC	INFAR1_proj
	; AFFINE MODE
	LDA	ARG1,U
	;
	; IF IN AFFINE MODE AND ARG1 = PLUS INFINITY
	; THEN SIGNAL ARG1 > ARG2.
	;
   	BLT	1F
	LDB	#BIT3		; SET  >
	BRA	INFAR1_done
1
	;
	; ELSE IF IN AFFINE MODE AND ARG1 = MINUS
	; INFINITY THEN SIGNAL ARG1 > ARG2.
	;
	LDB	#BIT1		; SET  <
	BRA	INFAR1_done

INFAR1_proj
	;
	; ELSE IF IN PROJECTIVE MODE THEN SIGNAL UNORDERED
	;
	LDB	#BIT0

INFAR1_done
	;
	; PROCEED TO STEP II TO EITHER SET CCR OR
	; AFFIRM/DISAFFIRM A PREDICATE.
	;
	; XXXJRT tail-call?
	BSR	CMPST2
	RTS			; RETURN

;*****************************************************************
;
; PROCEDURE E:
;
; ARG1 AND ARG2 ARE BOTH INFINITY
;
;
; PROCEDURE  CMPINF
;
;    CMPINF HANDLES THE CASE OF COMPARE WHERE
; BOTH ARG1 AND ARG2 ARE INFINITY.
;
; CHECK CLOSURE MODE
;
CMPINF
	LDA	[PFPCB,U]
	LSRA			; CLOSURE MODE BIT
;
; IF IN PROJECTIVE MODE THEN SIGNAL ARG1 = ARG2
;
	BCS	CMPINF_affine
	LDB	#BIT2		; SET  =
	BRA	CMPINF_done

CMPINF_affine
	;
	; ELSE IN AFFINE MODE AND THE SIGNS OF THE
	; ARGUMENTS ARE THE SAME THEN SIGNAL ARG1 = ARG2
	;
	LDA	ARG1,U
	EORA	ARG2,U
	BLT	1F
	LDB	#BIT2		; SET  =
	BRA	CMPINF_done
1
	;
	; ELSE IF SIGNS NOT THE SAME SET PREDICATE BITS
	; ACCORDINGLY.
	;
	LDA	ARG1,U		; SIGN ARG1 IS NEG?
	BGE	1F
	LDB	#BIT1		; SET  <
	BRA	CMPINF_done
1
	; SIGN ARG1 IS POS.
	LDB	#BIT3		; SET  >

CMPINF_done
	;
	; PROCEED TO STEP II TO EITHER SET CC REG.
	; OR AFFIRM/DISAFFIRM A PREDICATE.
	;
	; XXXJRT tail-call?
	BSR  CMPST2
	RTS			; RETURN

;*****************************************************************
;
; PROCEDURE F:
;
; EITHER ARG1 OR ARG2 IS A NAN
;
;
; PROCEDURE NANCMP
;
;   NANCMP HANDLES A CMP WHERE EITHER ARG1 AND
; ARG2 IS A NAN.
;
NANCMP
	LDB	#BIT0		; SET UNORDERED
	;
	; PROCEED TO STEP II TO EITHER SET CC REG. OR
	; AFFIRM/DISAFFIRM A PREDICATE.
	;
	; XXXJRT tail-call?
	BSR	CMPST2
	RTS			; RETURN

;*****************************************************************
;
; PROCEDURE  G:
;
; BOTH ARG1 AND ARG2 ARE ZERO
;
;
; PROCEDURE CMPZER
;
;    CMPZER HANDLES THE CASE OF COMPARE WHERE
; BOTH ARG1 AND ARG2 ARE ZERO.
;
CMPZER
	LDB	#BIT2		; SET =
	;
	; PROCEED TO STEP II TO EITHER SET CC REG.
	; SO AFFIRM/DISAFFIRM A PREDICATE.
	;
	; XXXJRT tail-call?
	BSR	CMPST2
	RTS			; RETURN

;*****************************************************************
;
; PROCEDURE H:
;
;  ARG1 UNORMALIZED & ARG2 NORMALIZED
;
; PROCCEDURE  ARG1UN
;
;    ARGIUN HANDLES THE CASE OF COMPARE WHERE ARG1 IS
; UNORMALIZED. ARG1 IS NORMALIZED AS FAR AS THE LOWER BOUND ON THE
; EXPONENT ALLOWS.
;
;  ON ENTRY: U - STACK FRAME POINTER
;
;  ON EXIT:
;  IN PREDICATE COMPARES:
;	LOCATION CCREG ON THE STACCK FRAME CONTAINS THE
;  CONDITION ODES AS SET BY THE COMPARE.
;
;  IN PREDICATE COMPARES:
;	THE FIRST BYTE OF THE RESULTS FRACTION CONTAINS
;  TRUE($00) OR FALSE($FF) DEPENDING ON WHETHER THE
; PREDICATE WAS AFFIRMED OR DISAFFIRMED.
;
;	U - UNCHANGED
;	X,Y,D,CC - DESTROYED
;
ARG1UN
	;
	; CHOOSE ARG1
	;
	LEAX	ARG1,U
	;
	; NORMALIZE OPERAND AND PERFORM THE COMPARE AS WITH TWO NORMALIZED
	; OPERANDS
	;
	; XXXJRT tail-call?
	BSR	NRMCMP
	RTS			; RETURN

;*****************************************************************
;
; PROCEDURE I:
;
;  ARG2 UNORMALIZED & ARG1 NORMALIZED
;
; PROCCEDURE  ARG2UN
;
;    ARGIUN HANDLES THE CASE OF COMPARE WHERE ARG1 IS
; UNORMALIZED. ARG1 IS NORMALIZED AS FAR AS THE LOWER BOUND ON THE
; EXPONENT ALLOWS.
;
;  ON ENTRY: U - STACK FRAME POINTER
;
;  ON EXIT:
;  IN PREDICATE COMPARES:
;	LOCATION CCREG ON THE STACCK FRAME CONTAINS THE
;  CONDITION ODES AS SET BY THE COMPARE.
;
;  IN PREDICATE COMPARES:
;	THE FIRST BYTE OF THE RESULTS FRACTION CONTAINS
;  TRUE($00) OR FALSE($FF) DEPENDING ON WHETHER THE
; PREDICATE WAS AFFIRMED OR DISAFFIRMED.
;
;	U - UNCHANGED
;	X,Y,D,CC - DESTROYED
;
ARG2UN
	;
	; CHOOSE ARG2
	;
	LEAX	ARG2,U
	;
	; NORMALIZE OPERAND AND PERFORM THE COMPARE AS WITH TWO NORMALIZED
	; OPERANDS
	;
	; XXXJRT tail-call?
	BSR	NRMCMP
	RTS			; RETURN

;*****************************************************************
;
; PROCEDURE J:
;
;  ARG2 UNNORMALIZED & ARG1 UNNORMALIZED
;
; PROCCEDURE  BOTHUN
;
;     BOTHUN HANDLES THE CASE OF COMPARE WHERE BOTH
; ARG1 AND ARG2 ARE UNNORMALIZED. BOTH ARGUMENTS
; ARE NORMALIZED AS FAR AS THE LOWER BOUND ON THE EXPONENT
; ALLOWS.
;
;  ON ENTRY: U - STACK FRAME POINTER
;
;  ON EXIT:
;  IN PREDICATE COMPARES:
;	LOCATION CCREG ON THE STACCK FRAME CONTAINS THE
;  CONDITION ODES AS SET BY THE COMPARE.
;
;  IN PREDICATE COMPARES:
;	THE FIRST BYTE OF THE RESULTS FRACTION CONTAINS
;  TRUE($00) OR FALSE($FF) DEPENDING ON WHETHER THE
; PREDICATE WAS AFFIRMED OR DISAFFIRMED.
;
;	U - UNCHANGED
;	X,Y,D,CC - DESTROYED
;
BOTHUN
	;
	; NORMALIZE ARG1 & ARG2
	;
	LEAX	ARG1,U
	LBSR	LNORM
	LEAX	ARG2,U
	;
	; NORMALIZE OPERAND AND PERFORM THE COMPARE AS WITH TWO NORMALIZED
	; OPERANDS
	;
	; XXXJRT tail-call?
	BSR	NRMCMP
	RTS			; RETURN

;
; PROCEDURE  NRMCMP
;
;    PERFORMS A MAGNITUDE COMPARE WHEN ONE OF THE OPERANDS IS
; UNNORMALIZED.
;
; ON ENTRY: X - POINTS TO THE UNORMALIZED OPERAND
;	    ARG1 AND ARG2 CONTAIN THE INPUT OPERANDS
;
; ON EXIT: EITHER THE CONDITION CODES HAVE BEEN SET OR THE
;	   PREDICATES AFFIRMED/DISAFIRMED DEPENDING ON
;	   WHETHER OR NOT THE COMPARE IS A NON- PREDICATE
;	   OR PREDICATE COMPARE.
;
NRMCMP
	;
	; NORMALIZE THE UNNORMALIZED ARGUMENT.
	;
	LBSR	LNORM
	;
	; CHECK FOR BOTH ARGUMENTS BEING ZERO
	;
	LDA	TYPE1,U
	ADDA	TYPE2,U
	CMPA	#04		; BOTH ARGUMENTS ZERO?
	BEQ	CMPZER		; Yes, tail-call to CMPZER
	LBRA	MAGCMP		; No, tail-call to MAGCMP

;*****************************************************************
;
; COMPARE STEP II
;
; PROCEDURE CMPST2
;
;   CMPST2 DECIDES WHETHER THE COMPARE IS
; A PREDICATE OR NON-PREDICATE COMPARE AND
; EITHER SETS UP THE CONDITION CODES OR
; RETURNS TRUE/FALSE DEPENDING ON THE INPUT
; PREDICATES.
;
;
;
; FIRST SEE IF COMPARE IS A NON-PREDICATE OR
; PREDICATE COMPARE
;
CMPST2
	LDA	FUNCT,U		; FUNCTION CODE
	;
	; IF THE COMPARE IS A PREDICATE COMPARE THEN
	; JUMP OVER THE CODE THAT HANDLES NON-PREDICATE
	; COMPARES
	;
	CMPA	#FCPCMP
	BEQ	PCMP
	CMPA	#FCTPCM
	BEQ	PCMP

	;
	;  B E G I N   NON-PREDICATE HANDLER
	;
	;
	; CASE( PREDICATE BITS ) TO SEE WHICH
	; CC BIT TO SET.
	;
	LDA	CCREG,U		; GET CALLER'S CC REG
	ANDA	#$F0		; AND OUT PREVIOUS CONDITIONS
				; BUT SAVE E,F,H AND I BITS

	CMPB	#EQ
	BEQ	CMPST2_np_eq
	CMPB	#LT
	BEQ	CMPST2_np_lt
	CMPB	#UN
	BEQ	CMPST2_np_un

	; Default case is GT, which sets no CC bits.
	BRA	CMPST2_np_done

CMPST2_np_eq
	;
	; CASE OF EQUAL
	;
	ORA	#CCEQ
	BRA	CMPST2_np_done

CMPST2_np_lt
	;
	; CASE OF LT
	;
	ORA	#CCLT
	BRA	CMPST2_np_done

CMPST2_np_un
	;
	; CASE OF UNORDERED
	;
	ORA	#CCUN
	LDB	#ERRUN		; UNOR BIT
	ORB	TSTAT,U
	STB	TSTAT,U

CMPST2_np_done
	STA	CCREG,U		; STORE MODIFIED CC'S
	;
	; E N D  NON-PREDICATE HANDLER
	;
	; Original code branched to the RET label, which just
	; did RTS, so don't bother with the extra branch.
	;
	RTS

PCMP
	;
	;  B E G I N  PREDICATE HANDLER
	;
	; ELSE IF THE COMPARE IS A PREDICATE COMPARE
	; THEN CHECK THE PREDICATE BITS AGAINST OF THE
	; COMPARE AND RETURN EITHER TRUE OR FALSE
	;
	;
	; CHECK PREDICATES AND SET THE NE BIT PROPERLY
	;
	PSHS	B		; SAVE B ON STACK
	ANDB	#EQ		; CHECK EQUAL
	BNE	1F
	LDB	0,S
	ORB	#NE		; SET NOT EQUAL
	STB	0,S
1
	;
	; IF PREDICATE TRUE THEN PUT $00 IN THE
	; FIRST BYTE OF THE FRACTION; OTHERWISE
	; IF PREDICATE IS FALSE, STORE $FF.
	;
	; XXXJRT could simplify this block like so:
	;
	;	clr	FRACTR,U
	;	andb	TPARAM,U
	;	bne	1F
	;	dec	FRACTR,U
	; 1
	;
	; Current structure is just a direct translation of
	; the original IFCC-ELSE-ENDIF construct.
	;
	ANDB	TPARAM,U	; CHECK PREDICATES
	BEQ	1F		; Predicate true?
	CLR	FRACTR,U	; Yes.
	BRA	2F
1
	LDA	#$FF		; No.
	STA	FRACTR,U
2
	;
	; IF UNORDERED IS AFFIRMED THEN SET THE UNORDERED
	; FLAG IN THE STATUS BYTE; ADDITIONALLY IF THE
	; PREDICATE IS <> THEN SET THE RESULT TO TRUE
	; TO GIVE THE USER THE TEST FOR A NAN I.E. IF
	; A <> A RETURNS TRUE THEN 'A' IS A NAN.
	;
	PULS	A
	ANDA	#BIT0		; CHECK UNORDERED
	BEQ	1F		; Branch if not unordered.

	LDA	TSTAT,U		; SET UNORDERED FLAG
	ORA	#ERRUN
	STA	TSTAT,U

	LDA	TPARAM,U
	CMPA	#NE		; PREDICATE IS <> ?
	BNE	2F
	CLR	FRACTR,U	; Yes, SET RESULT TRUE
	BRA	1F
2
	CMPA	#EQ
	BEQ	1F
	CMPA	#UN
	BEQ	1F

	LDA	#6		; IOP CODE
	LBSR	IOPSET
1
	;
	;  E N D   PREDICATE HANDLER
	;
	RTS			; RETURN
