;
; NAM  INS
; TTL  DECIMAL INPUT ROUTINE
;
;    DEFINE  EXTERNAL REFERENCES
;
; XDEF	DECBIN
;
; XREF	PWRTEN,ROUND,CHKUNF,CHKOVF,RTNAN,OVFLNT,UNFLNT
; XREF	LNORM,FMUL,FDIV,FPMOVE,CLRES,IOPSUB,IOPSET
; XREF	RTZERO,DENORM
;
;
;    REVISION HISTORY:
;      DATE	  PROGRAMMER	     REASON
;
;    23.MAY.80	  G.WALKER &	     ORIGINAL
;    17.JUN.80	  G. STEVENS	     FIX DECBIN
;    05.AUG.80	  G. STEVENS	     FIX DECBIN( S FOR U TYPO )
;    28.AUG.80	  J. BONEY	     CLEAR INEXACT BEFORE LAST ROUND
;    28.AUG.80	  G. STEVENS	     CHECK FOR ZERO FRACTION STRING
;    24.OCT.80	  G. STEVENS	     FIX UP BCD MINUS SIGN PROBLEM
;    15.DEC.80	  G. STEVENS	     SET STIKY PROPERLY FOR FINAL ROUND
;    01.JUL.22    @thorpej           Updated for asm6809.  New
;                                    comments are in mixed-case.
;
; LOCAL EQUATES
;
DMINUS	EQU	$0F		; BCD STRING MINUS SIGN
DPLUS	EQU	00		; BCD STRING PLUS SIGN

;*****************************************************************
;
; PROCEDURE  STRBIN
;
;    STRBIN CONVERTS A SIGNED UNPACKED BCD STRING
; REPRESENTING A FLOATING PT. SIGNIFICAND AND CONVERTS
; IT TO A BINARY FLOATING PT. NO. IN INTERNAL FORMAT.
;
; ON ENTRY: X - POINTS TO THE INTERNAL STACK LOCATION
;		OF THE RESULTING FLOATING VALUE.
;
;	    Y - POINTS TO THE START OF THE BCD STRING
;
STRBIN
	;
	; CONVERT FRACTION STRING TO A BINARY INTEGER
	;
	LEAX	FRACT,X
	LBSR	STRINT
	LEAX	-FRACT,X
	;
	; SET THE SIGN OF THE RESULT TO THE SIGN OF THE
	; BCD STRING.
	;
	LDA	-1,Y		; SIGN OF THE BCD STRING
	CMPA	#DMINUS		; SIGN NEGATIVE?
	BNE	1F
	LDA	#$80
	STA	SIGN,X
1
	;
	; SET EXPONENT TO FRACTSIZE-1
	;
	LDD	#FRACSZ-9
	STD	EXP,X
	;
	; NORMALIZE SIGNIFICAND
	;
	LBSR	LNORM
	RTS			; RETURN

;*****************************************************************
;
; PROCEDURE  DECBIN
;
;	DECBIN CONVERTS A FLOATING PT. NO. THAT IS
; REPRESENTED BY AN UNPACKED BCD STRING INTO ITS
; INTERNAL BINARY REPRESENTATION. THE BCD STRING
; HAS THE FOLLOWING FORM:
;
; +-------------------+---+-----------------+---+
; | 19 DIGIT FRACT.   |SF | 4 DIGIT EXP.    |SE |
; +-------------------+---+-----------------+---+
;
;  SF = SIGN FRACTION ; 0 = PLUS, -1 = MINUS
;  SE = SIGN EXPONENT ;   SAME
;
; LOCAL STORAGE ON THE STACK
;
BDEXP	EQU	0		; BINARY DECIMAL EXPONENT
TCTL	EQU	BDEXP+2		; TEMP LOC. OF CTL. BYTE
TRND	EQU	TCTL+1		; TEMP LOC. OF ROUNDING PREC.

DECBIN
	;
	; CHECK FOR A ZERO FRACTION IF SO RETURN A TRUE ZERO
	;
	LDY	FRACT2,U
	LEAY	DECSIG,Y	; POINT AT THE DECIMAL EXPONENT
	CLRA
	LDB	A,Y		; GET FIRST DIGIT
	ANDB	#$0F		; MASK OFF UPPER NIBBLE

1	CMPB	#0
	BNE	1F
	INCA
	LDB	A,Y
	ANDB	#$0F
	CMPA	#SIGDIG
	BLT	1B
1
	CMPA	#SIGDIG		; FRACTIONS ALL ZEROS?
	BLT	1F
	LBSR	RTZERO		; RETURN A TRUE ZERO
	LBRA	EXITIN		; EXIT ROUTINE
1
	LEAS	-(TRND+1),S	; CREATE SPACE FOR LOCALS
	;
	; CONVERT BCD EXPONENT STRING TO A BINARY INTEGER
	; RESULT TO RESIDE IN EXP2
	;
	LDY	FRACT2,U
	LEAY	DECEXP,Y	; POINT Y AT THE BCD EXPONENT
	LEAX	BDEXP,S		; POINT TO THE LOC. OF THE BCD EXP.
	LDB	#EXPDIG		; NO. OF BCD DIGITS IN EXP
	LDA	#EXPLEN		; NO. OF BYTES IN BIN. DEC. EXP.
	LBSR	STRINT		; BCD STRING TO BIN. INTEGER
	;
	; CHECK THE SIGN OF THE EXPONENT; IF NEGATIVE
	; COMPLEMENT THE RESULT OF STRINT
	;
	LDY	FRACT2,U
	LDA	SE,Y
	CMPA	#DMINUS		; EXPONENT NEGATIVE?
	BNE	1F
	COM	BDEXP,S
	NEG	BDEXP+1,S
	BCS	1F
	INC	BDEXP,S
1
	;
	; CONVERT BCD FRACTION TO AN INTEGER VALUED FLOATING VALUE
	;
	LEAY	DECSIG,Y	; POINT TO  SIGN OF BCD FRACTION
	LEAX	RESULT,U 	; POINT TO THE LOC. OF F.P. RESULT
	LDB	#SIGDIG		; NO. OF BCD DIGITS IN FRACTION
	LDA	#SIGLEN-1	; NO. OF BYTES IN THE FRACTION
	BSR	STRBIN		; BCD STRING TO FLOATING INTEGER
	;
	; NOW MASSAGE THE FLOATING INTEGER SO THAT THE INFLUENCE
	; OF THE BASE 10 EXPONENT( BDEXP ) IS TAKEN INTO ACCOUNT
	; THIS IS DONE BY REPEATED MULTIPLICATIONS OR DIVISIONS
	; BY 10 USING THE BASE 10 EXPONENT AS A COUNTER FOR THIS
	; PROCCESS. THE BASE 10 EXPONENT MUST FIRST BE ADJUSTED
	; BY A FACTOR OF P TO TAKE INTO ACCOUNT THE LOCATION OF
	; DECIMAL IN THE ORIGINAL BCD FRACTION STRING. SINCE P
	; IS JUST THE LOCATION OF THE PT. FROM THE LEAST SIG.
	; END OF THE STRING, THEN ALL ONE DOES IS SUBTRACT P
	; FROM THE BASE 10 EXPONENT.
	;
	; ADJUSTS EXPONENT; SUBTRACT P FROM BDEXP
	;
	CLR	TPARAM,U
	LDD	TPARAM,U	; VALIDATE P
	BLT	2F		; P NEGATIVE, GO TO INVALID
	CMPD	#MAXP		; P too big?
	BLE	1F
2 ; INVLD
	LDA	#7		; SIGNAL INVALID OPERATION = 7
	LBSR	IOPSET
	LDD	#MAXP		; DEFAULT TO P = MAX
	STD	TPARAM,U
1
	LDD	BDEXP,S		; GET DECIMAL EXPONENT
	SUBD	TPARAM,U	; SUBTRACT P
	STD	BDEXP,S		; RESTORE DECIMAL EXPONENT
	;
	; PERFORM THE OPERATIONS IN EXTENDED PRECISION
	; WITH ROUND TO NERAEST IN EFFECT.
	;
	LDA	[PFPCB,U]	; GET CONTROL BYTE
	STA	TCTL,S		; SAVE IT
	ANDA	#$FF-(CTLRND+CTLSIZ)
	ORA	#PREXT+RN
	STA	[PFPCB,U]	; RESET CONTROL BYTE

	LDA	RPREC,U		; GET CURRENT ROUNDING PRECISION
	STA	TRND,S		; SAVE IT
	LDA	#EXT		; REPLACE WITH EXTENDED
	STA	RPREC,U
	;
	; SAVE THE FLOATING INTEGER,I , ON THE S STACK
	;
	LEAS	-ARGSIZ,S	; CREAT SPACE
	LEAX	RESULT,U	; SOURCE
	LEAY	0,S		; DESTINATION
	LBSR	FPMOVE		; MOVE I TO TEMP
	;
	; CALCULATE 10^[(W-P)] AND PLACE IT IN ARG2
	;
	LDD	BDEXP+ARGSIZ,S	; GET BASE TEN EXPONENT
	BGE	1F
	; BASE TEN EXPONENT NEGATIVE
	COMA
	COMB
	ADDD	#01
1
	LBSR	PWRTEN
	LEAY	ARG2,U		; DESTINATION
	LBSR	FPMOVE		; MOVE  10^[(W-P)]
	;
	; MOVE I BACK TO ARG1 AND DEPENDING ON THE SIGN OF THE
	; BASE TEN EXPONENT EITHER MULTIPLY IT BY 10^(W-P)
	; ( EXP. POSITIVE ) OR DIVIDE BY 10~(W-P) (EXP. NEGATIVE )
	;
	LEAX	0,S		; SOURCE
	LEAY	ARG1,U		; DESTINATION
	LBSR	FPMOVE		; MOVE I TO ARG1

	LEAS	ARGSIZ,S	; REMOVE TEMP I FROM STACK
	;
	; ZERO OUT THE STACK FRAME RESULT
	;
	LEAX	RESULT,U
	LDB	#CLRALL		; CLEAR ALL OF THE ARGUMENT
	LBSR	CLRES

	LDD	BDEXP,S		; CHECK SIGN BASE TEN EXP.
	BLT	1F
	; BASE TEN EXPONENT POSITIVE
	LBSR	FMUL		; MULTIPLY I * 10^(W-P)
	BRA	2F
1
	; BASE TEN EXPONENT NEGATIVE
	LBSR	FDIV		; DIVIDE I / 10~(W-P)
2
	;
	; RESTORE ORIGINAL CONTROL BYTE
	;
	LDD	TCTL,S		; ORIGINAL CTL. BYTE AND PREC.
	STA	[PFPCB,U]	; RESTORE CONTROL BYTE
	STB	RPREC,U		; RESTORE ROUNDING PRECISION
	;
	; CLEAR THE INEXACT BIT FROM ANY PREVIOUS OPERATIONS
	; THE FINAL ROUND OR THE CHECK FOR VALID RESULT
	; WILL HAVE FINAL SAY ON INEXACT.
	;
	LDA	TPARAM,U
	ANDA	#$FF-ERRINX	; CLEAR INEXACT BIT
	STA	TPARAM,U
	;
	; SET UP THE FINAL ROUND
	;
	LEAX	RESULT,U	; POINTER TO THE ARGUMENT
	CLR	STIKY,U		; CLEAR STICKY FROM PREVIOUS ROUND
	CLRB			; NO SHIFTING IN DENORM
	LBSR	DENORM		; SET STIKY
	;
	; NOW ROUND THE RESULT TO THE DESIRED PRECISION AS
	; PER CALLERS ROUNDING MODE AND PRECISION
	;
	LBSR	ROUND
	;
	; CHECK FOR OVERFLOW AND UNDERFLOW AND TAKE APPROPRIATE
	; ACTION DEPENDING WHETHER TRAPS ARE ENABLED OR NOT.
	;
	LBSR	CHKUNF		; CHECK FOR UNDERFLOW
	BNE	1F
	;
	; IF TRAPS ENABLED THEN RETURN A "NAN" ELSE INVOKE
	; UNFL_NO_TRAP
	;
	LDY	PFPCB,U		; POINT AT CONTROL BLOCK
	LDA	ENB,Y
	ANDA	#ENBUNF		; UNDEFLOW TRAP ENABLE FLAG
	BEQ	2F
	LBSR	RTNAN		; RETURN A "NAN"
	BRA	1F
2	; TRAP DISABLED
	LBSR	UNFLNT		; NO TRAP HANDLER
1
	;
	; CHECK FOR OVERFLOW
	;
	LBSR	CHKOVF
	BNE	1F
	;
	; IF TRAPS ENABLED THEN RETURN A "NAN" ELSE INVOKE
	; OVFL_NO_TRAP
	;
	LDY	PFPCB,U		; LOOK AT CONTROL BLOCK
	LDA	ENB,U
	ANDA	#ENBOVF		; OVERFLOW TRAP ENABLE FLAG
	BEQ	2F
	LBSR	RTNAN		; RETURN A "NAN"
	BRA	1F
2	; TRAP DISABLED
	LBSR	OVFLNT		; NO TRAP HANDLER
1
; EXTINS (symbol not referenced); EXIT POINT FOR INS
	LEAS	(TRND+1),S	; CLEAN UP LOCCALS FROM STACK

EXITIN				; DECBIN EXIT POINT
	RTS			; RETURN

;
; LOCAL EQUATES
;
EXPLEN	EQU	2
SIGLEN	EQU	9
ACCLEN	EQU	SIGLEN-1

;*****************************************************************
;
;   MUL10
;
;     MUL10 TAKES A MULTI- PRECISION BINARY INTEGER
; AND MULTIPLIES IT BY 10. THIS OPERATION IS USEFULL
; FOR PERFORMING DECIMAL TO BINARY CONVERSIONS. UPON
; INVOCATION REG. X MUST POINT TO THE MSBYTE OF THE
; MULTI-BYTE ARGUMENT.
;
; N.B. This was originally a macro, but was rewritten as a
; subroutine because the macro version could not be replicated
; with asm6809.  This doesn't seem especailly performance-
; critical, and any additional cycles due having to be called
; as a subroutine can likely be clawed back elsewhere.
; --thorpej 1 July 2022
;
; XXXJRT This routine has a few opportunities for optimization.
;
; ON ENTRY: X - POINTS TO THE MSBYTE OF THE INPUT OPERAND.
;           B - BYTE LENGTH OF OPERAND
;
; ON EXIT: THE INPUT ARGUMENT IS MULTIPLIED BY 10
;
;          X AND B ARE UNCHANGED; A DESTROYED
;
MUL10
	PSHS	B,U		; save B and U
	LEAU	,S		; U points to operand length
	;
	; CREATE A TEMPORARY A TEMPORARY ACCUMULATOR ON THE STACK
	;
	NEGB
	LEAS	B,S
	;
	; MULTIPLY INPUT BY 2 I.E. LEFT SHIFT ONCE
	;
	LDA	,U		; A = byte count
	BSR	MULLSHIFT

	;
	; COPY ARG*2 TO A TEMPORARY ACCUMULATOR
	;
	LDB	,U		; ARGUMENT SIZE
1	CMPB	0
	BLE	1F
	DECB
	LDA	B,X		; SOURCE
	STA	B,S		; DESTINATION
1
	;
	; LEFT SHIFT ARGUMENT TWICE MORE TO YIELD 8*
	; INPUT ARGUMENT.
	;
	LDB	#2		; Push #2 onto the stack for a counter
	PSHS	B
1
	LDA	,U		; A = byte count
	BSR	MULLSHIFT
	DEC	,S
	BNE	1B
1
	LEAS	1,S		; Pop loop counter.

	;
	; NOW ADD 8*INPUT TO 2*INPUT TO YIELD 10*INPUT
	;
	LDB	,U		; ARGUMENT LENGTH
	DECB			; CONVERT LENGTH TO OFFSET
	CLRA
1	CMPB	#0
	BLT	1F
	RORA			; RESTORE CARRY
	LDA	B,X		; GET ARG1
	ADCA	B,S		; ADD IN ARG2
	STA	B,X		; SAVE RESULT
	ROLA			; SAVE CARRY IN A
	DECB
	BRA	1B
1
	LDB	,U
	LEAS	B,S		; CLEAN UP STACK
	PULS	B,U,PC		; Restore and return.

;
; MULLSHIFT
;
; Local subroutine to replace the non-constant invocation of the
; LSHIFT macro.
;
; ON ENTRY: X - points to the multi-precision binary integer to
;           shift leftwards.
;
;           A - size of the argument pointed to by X
;
; ON EXIT: The binary integer argument will be shifted in-place.
;
;          A destroyed.
;
MULLSHIFT
	DECA			; Convert length to offset.
	ANDCC	#NC		; Clear carry.
1
	ROL	A,X		; carry <- value <- carry
	DECA			; Decrement offset ** DOES NOT AFFECT CARRY **
	BPL	1B		; Done if offset underflows to -1S
	RTS

;*****************************************************************
;
; PROCEDURE  STRINT
;
;     STRINT CONVERTS AN UNSIGNED DECIMAL VALUE( RE-
; PRESENTED BY AN ARRAY OF UNPACKED BCD DIGITS) TO
; AN UNSIGNED BINARY INTEGER .
;
; ON ENTRY: Y - POINTS TO THE START OF THE BCD ARRAY
;
;	    X - POINTS TO THE START OF THE ACCUMULATOR
;		FOR THE BINARY RESULT.
;
;	    A - CONTAINS THE LENGTH OF THE BINARY RESULT
;		( IN BYTES )
;
;	    B - CONTAINS THE NUMBER OF BYTES IN THE BCD ARRAY
;
; ON EXIT: THE BINARY ACCUMULATOR POINTED TO BY X CONTAINS
;	   THE BINARY INTEGER EQUIVALENT TO THE BCD STRING.
;
;	   X, Y, A, B - UNCHANGED
;
; LOCAL STORAGE ON THE STACK
;
;	      0,S - BYTE LENGTH OF THE BINARY RESULT
;	      1,S - BYTE LENGTH OF THE BCD ARRAY
;	      2,S - POINTER TO THE BINARY RESULT
;	      4,S - POINTER TO THE BCD ARRAY
;
STRINT
	PSHS	X,Y,A,B		; SAVE CALLERS REGISTERS
	;
	; ZERO OUT THE BINARY ACCUMULATOR
	;
1	CMPA	#0
	BLE	1F
	DECA
	CLR	A,X
	BRA	1B
1
	;
	; SKIP OVER THE LEADING ZEROS IN THE BCD ARRAY
	;
	CLRA
	LDB	A,Y
1	CMPB	#0
	BNE	1F
	INCA
	LDB	A,Y
	CMPA	1,S		; BYTE INDEX = MAX INDEX?
	BNE	1B		; No, keep looping.
1
	;
	; CONVERT REMAINING BCD DIGITS TO BINARY INTEGER
STRINT_loop
	CMPA	1,S
	BGE	STRINT_out

	;
	; SAVE BYTE INDEX INTO BCD ARRAY
	;
	PSHS	A
	;
	; MULTIPLY BINARY ACCUMULATOR BY 10
	;
	LDB	1,S		; BINARY ACCUMULATOR LENGTH
	BSR	MUL10
	;
	; ADD IN NEXT BCD DIGIT TO BINARY ACCUMULATOR
	;
	LDA	0,S		; BCD BYTE INDEX
	LDA	A,Y		; GET NEXT BCD DIGIT
	ANDA	#$0F		; MASK OFF UPPER NIBBLE
	LDB	1,S		; BIN. ACC. LENGTH
	DECB			; OFFSET TO LSBYTE OF BIN ACC
	ADDA	B,X
	STA	B,X
	;
	; PROPAGATE CARRY TO HIGHER ORDER BYTES
	;
	ANDA	#0		; CLEAR A, SAVE CCR
	ROLA			; SAVE CARRY
	DECB
1	CMPB	#0		; loop to propagate carry
	BLT	1F
	TSTA			; Carry to propagate?
	BEQ	1F		; Nope, all done.
	ADDA	B,X		; ADD IN CARRY
	STA	B,X
	ANDA	#0		; CLEAR A, SAVE CCR
	ROLA			; SAVE CARRY
	DECB
	BRA	1B
1
	;
	; INCREMENT BYTE INDEX
	;
	PULS	A
	INCA

	BRA	STRINT_loop
STRINT_out
	PULS	X,Y,A,B,PC	; RESTORE AND RETURN
