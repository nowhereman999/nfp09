;
; NAM  PROCS
;
; LINKING LOADER DEFINITIONS
;
; XDEF  TFRACT,LNORM,SNORM,PREC,SIZE,SIZTAB,ENORM
;
; REVISION HISTORY:
;
;   DATE        PROGRAMMER     REASON
;
;  28.MAY.80    G. STEVENS     ORIGINAL
;  06.JUN.80    G. STEVENS     FIX TFRACT
;  10.JUL.80    J. BONEY       CHANGE TFRACT,SNORM
;  15.JUL.80    J. BONEY       MAKE ENORM,SNORM & LNORM
;                              USE MUTUAL CODE.
;  19.AUG.80    G. STEVENS     LNORM SETS TYPE PROPERLY
;  20.AUG.80    J. BONEY       SPEED UP TFRACT
;  08.0CT.80    G. STEVENS     CORRECT STACK OFFSET IN ENORM
;  09.OCT.80    G. STEVENS     CORRECT ADDR. MODE IN TFRACT
;  26.JUN.22    @thorpej       Updated for asm6809.  New comments
;                              are in mixed-case.
;*****************************************************************
;
;    G L O B A L  P R O C E D U R E S
;
;*****************************************************************
;
;   THESE PROCEDURES ARE USED BY ALL MODULES AND
;   HENCE ARE GLOBAL.
;
;   IF THESE PROCEDURES NEED SUB-PROCEDURES, THEY ARE
;   INCLUDED HERE. IF THE SUB-PROCEDURES ARE
;   GENERAL PURPOSE, THEY ARE CONSIDERED PROCEDURES
;   IN THEIR OWN RIGHT
;
;   IF PROCEDURES ARE ONLY USED LOCALLY BY A MODULE
;   THEY ARE NOT INCLUDED HERE.  THEY ARE
;   IN THE MODULE THAT USES THEM
;
;*****************************************************************
;
; TFRACT - TEST FRACTION FOR ZERO
;    AND SETS THE Z BIT IF THE RESULT IS ZERO
;
; ENTRY:
;    X = POINTER TO ARGUMENT ON STACK FRAME
;
; EXIT:
;    D = DESTROYED
;    Z = 1 IF ALL FRACTION BITS ARE ZERO
;
TFRACT
	LDD	FRACT,X		; TEST FOR ZERO 2 BYTES AT A TIME
	BNE	1F
	LDD	FRACT+2,X
	BNE	1F		; EXIT AS SOON AS A NON ZERO WORD OCCURS
	LDD	FRACT+4,X
	BNE	1F
	LDD	FRACT+6,X
	BNE	1F
	LDA	FRACT+8,X	; CHECK LAST BYTE
1
	RTS			; EXIT WITH Z

;*****************************************************************
;
;   LNORM,SNORM - NORMALIZE A NUMBER
;           THAT IS IN INTERNAL FORM
;
;   ON ENTRY: X POINTS TO THE ARGUMENT ON THE STACK FRAME
;
;   ON EXIT:  THE NUMBER POINTED TO BY X IS NORMALIZED
;             Z IS SET IF FRACTION WAS ZERO. ALSO THE
;               NUMBER IS SET TO TRUE ZERO
;             V IS SET IF NUMBER BECAME DENORMALIZED
;               DURING NORMALIZATION.
;             Z AND V ARE CLEARED OTHERWISE
;
;   NOTE: MUCH OF THE CODE IS SHARED WITH THE 'ENORM'
;   PROCEDURE. IT IS IDENTICAL TO SNORM/LNORM EXCEPT
;   FOR ITS LOOP TERMINATION CONDITIONS. THEREFORE
;   SNORM/LNORM PUSH A FLAG ON THE STACK THAT IS USED
;   BY THE MUTUAL CODE TO DETERMINE WHICH LOOP TERMINATOR
;   TO USE.
;
;*****************************************************************
SNORM				; DOUBLE ENTRY FOR THIS ROUTINE
LNORM
	PSHS	D,Y		; SAVE CALLER'S REGS
	CLR	TYPE,X		; SET TYPE TO NORMALIZED
	CLR	,-S		; FLAG = 0 = SNORM,LNORM CALL

MUTNRM				; ENORM ENTRY PT.
	BSR	TFRACT		; IF FRACTION = 0 THEN
	; IFCC  EQ
	;   MOVD  #$8000,(EXP,X)     SET TO ZERO
	;   MOVA #TYZERO,(TYPE,X)    CHANGE TYPE TO ZERO
	;   ORCC  #Z                 SET Z BIT (V=0)
	;   BRA SNOUT                EXIT
	; ENDIF
	BNE	1F
	LDD	#$8000		; SET TO ZERO
	STD	EXP,X
	LDA	#TYZERO		; CHANGE TYPE TO ZERO
	STA	TYPE,X
	ORCC	#Z		; SET Z BIT (V=0)
	BRA	SNOUT		; EXIT
1
	LDY	EXP,X		; PUT EXPONENT IN REG FOR SPEED
	LDA	FRACT,X		; PUT MSB OF FRACTION IN REG FOR SPEED
	TST	,S		; SNORM/LNORM call?
	BNE	1F		; No, ENORM call.
	TSTA			; Yes, check if already normalized.
	BMI	SNOUT
	BRA	SNLOOP
1
	CMPY	3,S		; Exit if already at original exponent
	BLE	SNOUT
SNLOOP
	DECY			; DEC EXPONENT
	CMPY	#$8000		; Down to minimum exponent?
	BNE	1F		; No, skip.
	STA	FRACT,X		; RESTORE FRACTION AND EXPONENT
	STY	EXP,X
	LDA	#TYNNRM		; CHANGE TYPE TO NOT NORMALIZED
	STA	TYPE,X
	ORCC	#V		; SET V BIT (Z=0)
	BRA	SNOUT
1
	LSL	FRACT+8,X	; SHIFT FRACTION 1 BIT LEFT
	ROL	FRACT+7,X
	ROL	FRACT+6,X
	ROL	FRACT+5,X
	ROL	FRACT+4,X
	ROL	FRACT+3,X
	ROL	FRACT+2,X
	ROL	FRACT+1,X
	ROLA

	TST	,S		; SNORM/LNORM call?
	BNE	1F		; No, ENORM call.
	TSTA			; Loop if not yet normalized.
	BPL	SNLOOP
	BRA	2F
1
	CMPY	3,S		; Loop if not at original exponent.
	BGE	SNLOOP
2
	STA	FRACT,X		; RESTORE FRCT AND EXPONENT
	STY	EXP,X
	ANDCC	#$F9		; CLEAR Z AND V BIT
SNOUT
	LEAS	1,S		; CLEAN UP STACK
	PULS	D,Y,PC		; RESTORE AND RETURN

;*****************************************************************
;
;    ENORM - NORMALIZE AN EXTENDED PRECISION NUMBER
;    THAT IS IN INTERNAL FORM TO ITS ORIGINAL
;    PRECISION
;
;    ON ENTRY: X POINTS TO ARGUMENT ON THE STACK FRAME
;              Y CONTAINS ORIGINAL EXPONENT OF THE ARG.
;
;    ON EXIT:  THE NUMBER POINTED TO BY X IS NORMALIZED
;    TO IT'S ORIGINAL PRECISION.
;              Z IS SET IF THE FRACTION WAS ZERO. ADDITIONALLY
;    THE NUMBER IS SET TO A TRUE ZERO
;              V IS SET IF THE NUMBER BECAME DENORMALIZED
;    DURING NORMALIZATION.
;
;    NOTE: MOST NUMBERS LEAVE THIS ROUTINE UNNORMALIZED.
;    SINCE THE INNER PORTION OF THE LOOP OF THIS ALGORITHM
;    WAS ALMOST IDENTICAL TO SNORM/LNORM THEY WERE COMBINED.
;    A FLAG IS PUSHED ONTO THE STACK BEFORE THE CALL TO
;    THE MUTUAL CODE TO DIFFERENTIATE THE UNSIMILAR CODE.
;
;*****************************************************************
ENORM
	PSHS	D,Y		; SAVE CALLERS'S REGS
	LDB	#1		; SET FLAG FOR
	STB	,-S		; ENORM CALL
	BRA	MUTNRM		; GO JOIN MUTUAL NORM. CODE

;*****************************************************************
;
; P R E C
;
;    THIS ROUTINE DETERMINES THE PRECISION OF AN ARGUMENT IN
;    USER MEMORY.  THE VALUE RETURNED IS AN INDEX
;    DEFINED AS:
;      SINGLE    = 0
;      DOUBLE    = 2
;      EXTENDED  = 4
;      EXTENDED ROUNDED TO SINGLE = 6
;      EXTENDED ROUNDED TO DOUBLE = 8
;
;    PREC KNOWS ABOUT MOV AND CMP AND WILL RETURN THE
;    PROPER PRECISION INDEX.
;
;    ENTRY:
;      U = POINTER TO STACK FRAME
;      FOR CMP B = 0 FOR ARG1; B.NE.0 FOR ARG2
;      FOR MOV B = 0 FOR ARG2; B.NE.0 FOR RESULT
;      FOR ALL OTHERS B IS A DON'T CARE
;
;    EXIT;
;      B = PRECISION INDEX
;      Z = 1 IFF B = 0
;      ALL REGISTERS RESTORED EXCEPT CC BITS
;
;   **** MAJOR REVISIONS *****
;    REVISOR      DATE      REASON
;    JOEL BONEY  022980    ORIGINAL
;    JOEL BONEY  031980    FASTER
;
;*****************************************************************
PREC
	TST	FUNCT,U		; Mixed arguments?
	BNE	1F		; Yes, go handle it.
	LDB	[PFPCB,U]	; GET FPCB CONTROL WORD. BITS 5-7 ARE PRECISION
	LSRB			; POSITION PRECISION IN 4LSB
	LSRB
	LSRB
	LSRB
	ANDB	#$0E		; PRECISION NOW 0,2,4,6 OR 8
	RTS			; ADIOS
1
	PSHS	A
	LDA	TPARAM+1,U	; GET PRECISION BYTE FROM STACK
	TST	B		; Upper nybble?
	BNE	1F		; No, lower nybble.
	ANDA	#$70		; POSITION IT
	LSRA
	LSRA
	LSRA
	BRA	2F
1
	ANDA	#$7		; POSITION IT
	LSLA
2
	TFR	A,B		; PUT RESULT IN B
	PULS	A,PC		; EXIT

;*****************************************************************
;
; S I Z E
;
;    THIS ROUTINE DETERMINES THE SIZE OF AN ARGUMENT IN
;    USER MEMORY.  THE VALUE RETURNED IS:
;      SINGLE    = 4
;      DOUBLE    = 8
;      EXTENDED  = 10
;
;    SIZE KNOWS ABOUT MOV AND CMP AND WILL RETURN THE
;    PROPER SIZE.
;
;    ENTRY:
;      U = POINTER TO STACK FRAME
;      FOR CMP B = 0 FOR ARG1; B.NE.0 FOR ARG2
;      FOR MOV B = 0 FOR ARG2; B.NE.0 FOR RESULT
;      FOR ALL OTHERS B IS A DON'T CARE
;
;    EXIT;
;      B = SIZE
;      ALL REGISTERS RESTORED EXCEPT CC BITS
;
;
;  ***** MAJOR REVISIONS *****
;   REVISOR     DATE      REASON
;   JOEL BONEY  022980    ORIGINAL
;
;*****************************************************************
SIZE
	PSHS	X
	LEAX	SIZTAB,PCR	; POINT TO SIZE TABLE
	BSR	PREC		; GO GET PRECISION
	LSRB			; DIVIDE INDEX BY 2
	LDB	B,X		; CONVERT TO SIZE
	PULS	X,PC
;
; TABLE TO CONVERT PRECISION INDEX TO SIZE
;
SIZTAB	FCB 4,8,10,10,10
